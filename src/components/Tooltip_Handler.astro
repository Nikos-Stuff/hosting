<script>
  document.addEventListener("DOMContentLoaded", () => {
    const tooltip: HTMLDivElement = document.createElement("div");
    tooltip.id = "custom-tooltip";
    tooltip.className = `
    fixed px-2 py-1 text-xs
    max-w-1/3
    line-clamp-4
    backdrop-blur-sm backdrop-saturate-200
    backdrop-contrast-200
    dark:bg-black/60 bg-white/60
    border border-black/10 dark:border-white/25
    rounded-lg rounded-tl-xs
    pointer-events-none
    opacity-0 transition-[opacity,border-radius] duration-150
    z-50
  `;
    document.body.appendChild(tooltip);

    let hoveredEl: HTMLElement | null = null;
    let observedEl: HTMLElement | null = null;
    let fadeTimeout: number | undefined;
    let tooltipCorner: "tl" | "tr" = "tl";

    let targetX = 0;
    let targetY = 0;
    let currentX = 0;
    let currentY = 0;
    const speed = 0.08;

    function setTooltipCorner(corner: "tl" | "tr") {
      if (tooltipCorner === corner) return;
      tooltip.classList.remove(`rounded-${tooltipCorner}-xs`);
      tooltip.classList.add(`rounded-${corner}-xs`);
      tooltipCorner = corner;
    }

    function animate(): void {
      currentX += (targetX - currentX) * speed;
      currentY += (targetY - currentY) * speed;
      tooltip.style.left = `${currentX}px`;
      tooltip.style.top = `${currentY}px`;
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    function hideTooltip(): void {
      hoveredEl = null;
      if (fadeTimeout !== undefined) {
        clearTimeout(fadeTimeout);
        fadeTimeout = undefined;
      }
      tooltip.classList.remove("opacity-100");
      tooltip.classList.add("opacity-0");
    }

    const io = new IntersectionObserver(
      (entries: IntersectionObserverEntry[]) => {
        for (const entry of entries) {
          if (!entry.isIntersecting && entry.target === hoveredEl) {
            hideTooltip();
          }
        }
      },
    );

    document.addEventListener("pointerover", (e: PointerEvent) => {
      const target = e.target;
      if (!(target instanceof Element)) return;

      const el = target.closest<HTMLElement>("[data-tooltip]");
      if (!el || el === hoveredEl) return;

      const text = el.dataset.tooltip;
      if (!text) return;

      hoveredEl = el;

      if (observedEl !== el) {
        if (observedEl) io.unobserve(observedEl);
        io.observe(el);
        observedEl = el;
      }

      tooltip.classList.add("opacity-0");
      if (fadeTimeout !== undefined) clearTimeout(fadeTimeout);

      fadeTimeout = window.setTimeout(() => {
        tooltip.textContent = text;
        tooltip.classList.remove("opacity-0");
        tooltip.classList.add("opacity-100");
      }, 120);
    });

    document.addEventListener("pointermove", (e: PointerEvent) => {
      if (!hoveredEl) return;

      const cursorOffsetX = 14;
      const cursorOffsetY = 18;
      const margin = 8;

      let x = e.clientX + cursorOffsetX;
      let y = e.clientY + cursorOffsetY;

      const tooltipRect = tooltip.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      let corner: "tl" | "tr" = "tl"; // default

      if (x + tooltipRect.width + margin > viewportWidth) {
        x = e.clientX - tooltipRect.width - margin;
        corner = "tr";
      }

      if (y + tooltipRect.height + margin > viewportHeight) {
        y = e.clientY - tooltipRect.height - margin;
      }

      x = Math.max(margin, x);
      y = Math.max(margin, y);

      targetX = x;
      targetY = y;

      setTooltipCorner(corner);
    });

    document.addEventListener("pointerout", (e: PointerEvent) => {
      if (!hoveredEl) return;

      const related = e.relatedTarget;
      if (related instanceof Node && hoveredEl.contains(related)) return;

      io.unobserve(hoveredEl);
      observedEl = null;
      hideTooltip();
    });
  });
</script>
