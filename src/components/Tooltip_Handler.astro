<script>
  document.addEventListener("DOMContentLoaded", () => {
    const tooltip = document.createElement("div");
    tooltip.id = "custom-tooltip";
    tooltip.className = `
      fixed px-2 py-1 text-xs
      max-w-1/3 h-fit
      top_left_rounded
      line-clamp-4
      overflow-hidden
      backdrop-blur-sm backdrop-saturate-200
      backdrop-contrast-200
      dark:bg-black/60 bg-white/60
      border border-black/10 dark:border-white/25
      pointer-events-none
      opacity-0 transition-[opacity,border-radius] duration-500 ease-in-out
      will-change-[transform,border-radius,opacity]
      z-50
    `;
    document.body.appendChild(tooltip);

    type Corner = "tl" | "tr" | "bl" | "br";
    let hoveredEl: HTMLElement | null = null;
    let observedEl: HTMLElement | null = null;
    let fadeTimeout: number | undefined;
    let tooltipCorner: Corner = "tl";

    let targetX = 0;
    let targetY = 0;
    let currentX = 0;
    let currentY = 0;
    const speed = 0.08;

    function animate() {
      currentX += (targetX - currentX) * speed;
      currentY += (targetY - currentY) * speed;
      tooltip.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    function setTooltipCorner(corner: Corner) {
      if (tooltipCorner === corner) return;

      const cornerClasses = {
        tl: "top_left_rounded",
        tr: "top_right_rounded",
        bl: "bottom_left_rounded",
        br: "bottom_right_rounded"
      };

      Object.values(cornerClasses).forEach(cls => tooltip.classList.remove(cls));
      
      tooltip.classList.add(cornerClasses[corner]);
      tooltipCorner = corner;
    }

    function hideTooltip() {
      hoveredEl = null;
      if (fadeTimeout !== undefined) clearTimeout(fadeTimeout);
      tooltip.classList.replace("opacity-100", "opacity-0");
    }

    const io = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        if (!entry.isIntersecting && entry.target === hoveredEl) hideTooltip();
      }
    });

    document.addEventListener("pointerover", (e: PointerEvent) => {
      const target = e.target;
      if (!(target instanceof HTMLElement)) return;
      const el = target.closest<HTMLElement>("[data-tooltip]");

      if (!el || el === hoveredEl) return;
      const text = el.dataset.tooltip;
      if (!text) return;

      hoveredEl = el;

      if (observedEl !== el) {
        if (observedEl) io.unobserve(observedEl);
        io.observe(el);
        observedEl = el;
      }

      if (fadeTimeout !== undefined) clearTimeout(fadeTimeout);

      tooltip.classList.replace("opacity-100", "opacity-0");

      fadeTimeout = window.setTimeout(() => {
        tooltip.textContent = text;
        tooltip.classList.replace("opacity-0", "opacity-100");
      }, 150); 
    });

    let rafId: number | null = null;
    document.addEventListener("pointermove", (e: PointerEvent) => {
      if (!hoveredEl) return;
      if (rafId) cancelAnimationFrame(rafId);
      
      rafId = requestAnimationFrame(() => {
        const offsetX = 14;
        const offsetY = 18;
        const margin = 8;

        const rect = tooltip.getBoundingClientRect();
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        let x = e.clientX + offsetX;
        let y = e.clientY + offsetY;
        let xSide: "l" | "r" = "l";
        let ySide: "t" | "b" = "t";

        // Flip Horizontal
        if (x + rect.width + margin > vw) {
          x = e.clientX - rect.width - margin;
          xSide = "r";
        }

        // Flip Vertical
        if (y + rect.height + margin > vh) {
          y = e.clientY - rect.height - margin;
          ySide = "b";
        }

        targetX = Math.max(margin, Math.min(x, vw - rect.width - margin));
        targetY = Math.max(margin, Math.min(y, vh - rect.height - margin));

        const cornerKey = `${ySide}${xSide}` as Corner;
        setTooltipCorner(cornerKey);
      });
    });

    document.addEventListener("pointerout", (e: PointerEvent) => {
      if (!hoveredEl) return;
      const related = e.relatedTarget;
      if (related instanceof Node && hoveredEl.contains(related)) return;
      if (observedEl) io.unobserve(observedEl);
      observedEl = null;
      hideTooltip();
    });
  });
</script>