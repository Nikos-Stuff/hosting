---
import PageLayout from "@layouts/PageLayout.astro";
import { SITE } from "@consts";
import MeteorShower from "@components/MeteorShower.astro";
import TwinklingStars from "@components/TwinklingStars.astro";
import BackgroundFX from "@components/page_effects/BackgroundFX.astro";
import POD from "@components/POD.astro";
import FancyDiv from "@components/FancyDiv.astro";
---

<PageLayout title="Pack Converter" description={SITE.DESCRIPTION}>
  <!-- <script is:inline data-astro-rerun async src="/js/scroll_animation.js"
  ></script> -->

  <POD />
  <!-- Light Mode: Particles -->
  <div class="absolute inset-0 block dark:hidden">
    <div id="particles1" class="fixed inset-0"></div>
    <div id="particles2" class="fixed inset-0"></div>
    <div id="particles3" class="fixed inset-0"></div>
  </div>

  <!-- Dark Theme: Stars -->
  <div class="absolute inset-0 hidden dark:block">
    <div id="stars1" class="fixed inset-0"></div>
    <div id="stars2" class="fixed inset-0"></div>
    <div id="stars3" class="fixed inset-0"></div>
  </div>

  <!-- Dark Theme: Twinkling Stars / Metors -->
  <div id="galaxy" class="fixed inset-0">
    <div class="hidden dark:block">
      <TwinklingStars />
      <MeteorShower />
    </div>
  </div>

  <!-- <script is:inline defer src="/js/bg.js"></script> -->
  <BackgroundFX />

  <!-- HERO -->
  <section
    id="hero_fade"
    class="snap-center grid w-full h-[20svh] place-items-center relative text-center overflow-hidden transition-all"
  >
    <!-- <div id="planetcont" class='animate absolute inset-0 top-3/4 overflow-hidden z-10'> PLANET HAS BEEN REMOVED FOR A TEST NEW LAYOUT 
            <div id="crescent"
                 class='absolute top-0 left-1/2 -translate-x-1/2 w-[250vw] min-h-[100vh] aspect-square rounded-full p-[1px] bg-gradient-to-b from-black/25 dark:from-white/75 from-0% to-transparent to-5%'>
                <div id="planet"
                     class='w-full h-full bg-white dark:bg-black rounded-full p-[1px] overflow-hidden flex justify-center'>
                    <div id="blur" class='w-full h-5 rounded-full bg-neutral-900/25 dark:bg-white/25 blur-2xl'/>
                </div>
            </div>
        </div> -->
  </section>

  <div class="relative">
    <div class="w-svw">
      <FancyDiv isAnimated={true} theme="default_big" margin_bottom="50">
        <div class="transition-all">
          <p
            class="text-xl md:text-2xl lg:text-3xl font-bold uppercase text-black dark:text-white animate"
          >
            Modpack Converter
          </p>
          <p class="font-bold text-sm mb-2 animate">
            Convert .mrpack files to .zip for easy installation (included .jars
            inside)
          </p>

          <div class="space-y-4 animate" id="calculator">
            <!-- URL input -->
            <div class="relative" id="url_input_div">
              <input
                id="url_input"
                type="text"
                placeholder="https://modrinth.com/modpack/example"
                class="w-full p-4 mt-5 border rounded-lg
          hover:bg-black/5 hover:dark:bg-white/10 border-black/15 dark:border-white/20
          transition-all duration-300 ease-in-out"
              />
            </div>

            <p class="text-center italic">or</p>

            <!-- File input-->
            <div class="relative" id="file_input_div">
              <input
                id="file_input"
                type="file"
                accept=".mrpack"
                class="hidden"
              />
              <label
                for="file_input"
                id="file_input_label"
                class="group w-full p-4 mt-5 flex items-center justify-between border rounded-lg
         hover:bg-black/5 hover:dark:bg-white/10 border-black/15 dark:border-white/20
         cursor-pointer transition-all duration-300 ease-in-out"
              >
                <span>Choose File…</span>
                <span
                  id="file_input_text"
                  class="text-gray-500 dark:text-gray-400">No file chosen</span
                >
              </label>
            </div>

            <!-- Convert button -->
            <div class="animate mb-0 hidden">
              <button
                id="convert_to_zip_btn"
                class="group w-full p-4 mt-5 gap-3 flex items-center border rounded-lg hover:bg-black/5 hover:dark:bg-white/10 border-black/15 dark:border-white/20 transition-all duration-300 ease-in-out"
              >
                <span
                  class="w-full z-10 relative group-hover:text-black group-hover:dark:text-white text-center transition-color duration-300"
                >
                  Convert to ZIP server pack!
                </span>
              </button>
            </div>
            <p class="mb-10 mt-0">
              <small
                >Runs in your browser — no uploads. External download links may
                be blocked by CORS.</small
              >
            </p>

            <!-- Modpack browser -->
            <div
              id="modpack_browser"
              class="flex flex-col gap-2 p-4 mt-2 border rounded-lg
              h-60 overflow-y-scroll
            hover:bg-black/5 hover:dark:bg-white/10
            border-black/15 dark:border-white/20
              transition-all duration-300 ease-in-out hide_scrollbar"
            >
              <div
                class="template flex items-center justify-between font-mono text-sm text-gray-700 dark:text-gray-300"
              >
                <div class="flex items-center gap-3 min-w-0">
                  <div
                    class="mod_circle h-2.5 w-2.5 rounded-full shrink-0 aspect-square bg-gray-400 dark:bg-gray-600 animate-pulse"
                  >
                  </div>
                  <span class="mod_name truncate min-w-0"> Mod Name </span>
                </div>
                <span
                  class="mod_status text-right whitespace-nowrap ml-3 shrink-0"
                >
                  Status
                </span>
              </div>
              <!-- content will be dynamically added here -->
            </div>

            <!-- Debug console -->
            <div
              id="debug_console"
              class="font-mono text-sm overflow-scroll h-30 w-full p-4 mt-5 border rounded-lg
              flex flex-col justify-between gap-2
            hover:bg-black/5 hover:dark:bg-white/10
            border-black/15 dark:border-white/20
              transition-all duration-300 ease-in-out hide_scrollbar"
            >
              <div id="log_messages">Waiting for file...</div>
              <div
                id="progress-line"
                class="text-gray-700 dark:text-gray-300 whitespace-pre"
              >
                <!-- progress will update here -->
              </div>
            </div>

            <!-- Resources usage bars -->
            <div class="mt-4 flex gap-4">
              <div class="flex-1">
                <div
                  class="w-full bg-gray-300 dark:bg-gray-700 rounded-full h-[0.3px]"
                >
                  <div
                    id="cpu_usage"
                    class="dark:bg-white bg-black h-[0.3px] rounded-full transition-all duration-500 ease-in-out"
                    style="width: 0%"
                  >
                  </div>
                </div>
              </div>

              <div class="flex-1">
                <div
                  class="w-full bg-gray-300 dark:bg-gray-700 rounded-full h-[0.3px]"
                >
                  <div
                    id="progress_bar"
                    class="dark:bg-white bg-black h-[0.3px] rounded-full transition-all duration-500 ease-in-out"
                    style="width: 0%"
                  >
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </FancyDiv>
      <FancyDiv isAnimated={true} theme="default_big">
        <div class="transition-all">
          <h2
            class="text-2xl md:text-3xl lg:text-4xl font-bold uppercase text-black dark:text-white animate"
          >
            How to use
          </h2>
          <ol class="list-decimal list-inside space-y-2 mt-4 animate">
            <li>
              Obtain a <code>.mrpack</code> file from a Modrinth modpack page.
            </li>
            <li>
              Either upload the <code>.mrpack</code> file using the "Choose File…"
              button, or paste the modpack URL into the input field at the top.
            </li>
            <li>
              Wait for the process to complete. The log and mod browser will
              update with progress information.
            </li>
            <li>
              Once finished, a ZIP file will be automatically downloaded to your
              device.
            </li>
            <li>
              Extract the ZIP file and install the included JAR files on your
              server.
            </li>
            <li>
              If any client-only mods were removed, refer to the
              <code>deleted_mods.txt</code> file inside the ZIP for details.
            </li>
          </ol>
        </div>
      </FancyDiv>
    </div>
  </div>
</PageLayout>

<script>
  import JSZip from "jszip";

  const fileInput = document.getElementById(
    "file_input",
  ) as HTMLInputElement | null;
  const convertBtn = document.getElementById(
    "convert_to_zip_btn",
  ) as HTMLButtonElement | null;
  const debugConsole = document.getElementById(
    "debug_console",
  ) as HTMLDivElement | null;
  const fileInputText = document.getElementById(
    "file_input_text",
  ) as HTMLSpanElement | null;
  const modpack_browser = document.getElementById(
    "modpack_browser",
  ) as HTMLDivElement | null;
  const url_input = document.getElementById(
    "url_input",
  ) as HTMLInputElement | null;
  const cpu_usage_bar = document.getElementById(
    "cpu_usage",
  ) as HTMLDivElement | null;
  const progress_bar = document.getElementById(
    "progress_bar",
  ) as HTMLDivElement | null;

  const deleted_mods: string[] = [];
  let already_running = false;

  if (!fileInput || !convertBtn || !debugConsole) {
    throw new Error("Required DOM elements not found");
  }

  // grab url params eg ?modpack_id=xyz
  const urlParams = new URLSearchParams(window.location.search);

  type LogLevel = "info" | "warn" | "error" | "success";

  const LOG_COLORS: Record<LogLevel, string> = {
    info: "text-blue-600 dark:text-blue-400",
    warn: "text-yellow-600 dark:text-yellow-400",
    error: "text-red-600 dark:text-red-400",
    success: "text-green-600 dark:text-green-400",
  };

  const STATUS_COLORS: Record<string, string[]> = {
    Queued: ["bg-gray-400", "dark:bg-gray-600"],
    "Downloading...": ["bg-blue-500"],
    Downloaded: ["bg-blue-300"],
    Imported: ["bg-green-500"],
    Failed: ["bg-red-500"],
    Removed: ["bg-yellow-500"],
    Analyzing: ["bg-purple-500"],
  };

  type Phase =
    | "load"
    | "download"
    | "overrides"
    | "metadata"
    | "cleanup"
    | "compress";

  const PHASE_WEIGHTS: Record<Phase, number> = {
    load: 5,
    download: 45,
    overrides: 10,
    metadata: 15,
    cleanup: 10,
    compress: 15,
  };

  const phaseProgress: Record<Phase, number> = {
    load: 0,
    download: 0,
    overrides: 0,
    metadata: 0,
    cleanup: 0,
    compress: 0,
  };

  let monitorInterval: number | null = null;
  const lagSamples: number[] = [];
  const LAG_WINDOW_MS = 5000;
  const INTERVAL_MS = 500;

  // ---------------------------------------------------------------

  function updateCircleColor(circle: HTMLDivElement, status: string) {
    const classesToRemove = Array.from(circle.classList).filter(
      (c) => c.startsWith("bg-") || c.startsWith("dark:bg-"),
    );
    circle.classList.remove(...classesToRemove);

    const newClasses = STATUS_COLORS[status] || [
      "bg-gray-400",
      "dark:bg-gray-600",
    ];
    circle.classList.add(...newClasses);
  }

  function add_to_browser_mod_list(mod_name: string, status: string) {
    if (!modpack_browser) return;

    const template = modpack_browser.querySelector(
      ".template",
    ) as HTMLDivElement;
    if (!template) return;

    const modEntry = template.cloneNode(true) as HTMLDivElement;
    modEntry.classList.remove("template");

    const modNameSpan = modEntry.querySelector(".mod_name") as HTMLSpanElement;
    const modStatusSpan = modEntry.querySelector(
      ".mod_status",
    ) as HTMLSpanElement;
    const statusCircle = modEntry.querySelector(
      ".mod_circle",
    ) as HTMLDivElement;

    if (modNameSpan) modNameSpan.textContent = mod_name;
    if (modStatusSpan) modStatusSpan.textContent = status;
    if (statusCircle) updateCircleColor(statusCircle, status);

    modpack_browser.appendChild(modEntry);
  }

  function update_in_browser_mod_list(mod_name: string, status: string) {
    if (!modpack_browser) return;

    const entries = modpack_browser.querySelectorAll(
      "div:not(.template)",
    ) as NodeListOf<HTMLDivElement>;

    entries.forEach((entry) => {
      const modNameSpan = entry.querySelector(".mod_name") as HTMLSpanElement;
      const modStatusSpan = entry.querySelector(
        ".mod_status",
      ) as HTMLSpanElement;
      const statusCircle = entry.querySelector(".mod_circle") as HTMLDivElement;

      if (modNameSpan && modNameSpan.textContent === mod_name) {
        if (modStatusSpan) modStatusSpan.textContent = status;
        if (statusCircle) updateCircleColor(statusCircle, status);
      }
    });

    // scroll to the updated mod only inside the modpack browser
    const targetEntry = Array.from(entries).find((entry) => {
      const modNameSpan = entry.querySelector(".mod_name") as HTMLSpanElement;
      return modNameSpan && modNameSpan.textContent === mod_name;
    });
    if (targetEntry && modpack_browser) {
      const container = modpack_browser as HTMLElement;
      const entry = targetEntry as HTMLElement;

      // compute entry position relative to the container and center it
      const containerRect = container.getBoundingClientRect();
      const entryRect = entry.getBoundingClientRect();
      const offset =
        entryRect.top -
        containerRect.top +
        container.scrollTop -
        container.clientHeight / 2 +
        entry.clientHeight / 2;

      container.scrollTo({ top: offset, behavior: "smooth" });
    }
  }

  function clean_browser_mod_list() {
    if (!modpack_browser) return;

    Array.from(modpack_browser.children).forEach((child) => {
      const el = child as HTMLDivElement;
      if (!el.classList.contains("template")) {
        el.remove();
      }
    });
  }

  function reset_phase_progress() {
    for (const phase in phaseProgress) {
      phaseProgress[phase as Phase] = 0;
    }
    updateOverallProgressBar();
  }

  function clear_log() {
    const container = document.getElementById("log_messages");
    if (container) {
      container.innerHTML = "";
    }
  }

  function log(message: string, level: LogLevel = "info") {
    const time = new Date().toLocaleTimeString();
    const line = `
    <div class="${LOG_COLORS[level]}">
      [${time}] ${message}
    </div>
  `;
    const container = document.getElementById("log_messages");
    if (container) {
      container.innerHTML += line;
      debugConsole!.scrollTop = debugConsole!.scrollHeight;
    }
  }

  //  const PROGRESS_ID = "progress-line";

  function formatETA(seconds: number): string {
    if (!isFinite(seconds) || seconds <= 0) return "calculating…";
    if (seconds < 60) return `${Math.ceil(seconds)}s`;
    const m = Math.floor(seconds / 60);
    const s = Math.ceil(seconds % 60);
    return `${m}m ${s}s`;
  }

  function renderProgress(
    label: string,
    current: number,
    total: number,
    startTime: number,
  ) {
    const percent =
      total > 0 ? Math.min(100, Math.floor((current / total) * 100)) : 0;
    const barLength = 20;
    const filled = Math.floor((percent / 100) * barLength);
    const remainingBar = barLength - filled;

    const bar =
      "=".repeat(filled) +
      (remainingBar > 0 ? ">" : "") +
      " ".repeat(Math.max(0, remainingBar - 1));

    const elapsed = (performance.now() - startTime) / 1000;
    const rate = current / elapsed;
    const remainingTime = rate > 0 ? (total - current) / rate : Infinity;

    const progressDiv = document.getElementById("progress-line");
    if (progressDiv) {
      progressDiv.innerHTML = `${label} [${bar}] ${percent}% • ETA ${formatETA(remainingTime)}`;
    }

    debugConsole!.scrollTop = debugConsole!.scrollHeight;
  }

  function extractProjectId(url: string): string | null {
    const match = url.match(/cdn\.modrinth\.com\/data\/([^/]+)\//);
    return match?.[1] ?? null;
  }

  function updateCPUbar(cpuPercent: number | null) {
    if (cpu_usage_bar) {
      cpu_usage_bar.style.width = `${cpuPercent ?? 0}%`;
      cpu_usage_bar.title =
        cpuPercent !== null
          ? `CPU approx: ${Math.round(cpuPercent)}%`
          : "CPU approx: N/A";
    }
  }

  function getOverallProgressPercent(): number {
    let total = 0;

    for (const phase in PHASE_WEIGHTS) {
      const p = phase as Phase;
      total += phaseProgress[p] * PHASE_WEIGHTS[p];
    }

    return Math.min(100, Math.max(0, total));
  }

  function updateOverallProgressBar() {
    const pct = getOverallProgressPercent();

    if (!progress_bar) return;

    progress_bar.style.width = `${pct}%`;
    progress_bar.title = `Overall progress: ${Math.round(pct)}%`;
  }

  function setPhaseProgress(phase: Phase, value: number) {
    phaseProgress[phase] = Math.max(phaseProgress[phase], Math.min(1, value));
    updateOverallProgressBar();
  }

  // lag based CPU approximation
  let lastTick = performance.now();
  function monitorLoop() {
    const now = performance.now();
    const delta = now - lastTick;
    lastTick = now;
    // expected interval ~ INTERVAL_MS; lag = how much slower than expected
    const lag = Math.max(0, delta - INTERVAL_MS);
    lagSamples.push(lag);
    // keep window
    //const cutoff = now - LAG_WINDOW_MS;
    while (
      lagSamples.length > 0 &&
      lagSamples.length * INTERVAL_MS > LAG_WINDOW_MS
    ) {
      lagSamples.shift();
    }

    // average lag over samples
    const avgLag =
      lagSamples.reduce((a, b) => a + b, 0) / Math.max(1, lagSamples.length);

    // map avgLag to a rough CPU percent: 0 lag -> ~5% , 200ms lag -> ~100%
    const cpuPercent = Math.min(100, Math.max(0, (avgLag / 200) * 100));

    // const memPercent = getMemoryUsagePercent();

    updateCPUbar(
      Math.round(cpuPercent),
      // memPercent !== null ? Math.round(memPercent) : null,
    );
  }

  function startMonitoring() {
    if (monitorInterval !== null) return;
    lastTick = performance.now();
    monitorInterval = window.setInterval(monitorLoop, INTERVAL_MS);
  }

  function stopMonitoring() {
    if (monitorInterval !== null) {
      clearInterval(monitorInterval);
      monitorInterval = null;
    }
  }

  // start monitoring immediately
  startMonitoring();

  // ---------------------------------------------------------------

  async function main(file: File | Blob) {
    try {
      if (already_running) {
        log("Conversion already in progress. Please wait.", "warn");
        return;
      }

      clean_browser_mod_list();
      clear_log();
      reset_phase_progress();

      already_running = true;

      // --- Load phase ---
      setPhaseProgress("load", 0);
      const mrpackZip = await JSZip.loadAsync(file);
      log("MRPACK loaded.", "success");
      setPhaseProgress("load", 1);

      const indexFile = mrpackZip.file("modrinth.index.json");
      if (!indexFile) throw new Error("modrinth.index.json not found");

      const index = JSON.parse(await indexFile.async("string"));

      log(`Modpack: ${index.name} (${index.versionId})`, "info");
      log(`Mods to download: ${index.files.length}`, "info");

      const outputZip = new JSZip();

      // Populate browser mod list
      log(`Populating mod browser...`, "info");
      index.files.forEach((mod: { path: string }) => {
        add_to_browser_mod_list(mod.path, "Queued");
      });

      // --- Download phase ---
      setPhaseProgress("download", 0);
      const modStart = performance.now();
      for (let i = 0; i < index.files.length; i++) {
        const mod = index.files[i];
        const url = mod.downloads?.[0];

        if (!url) {
          log(`Skipping ${mod.path} (no URL)`, "warn");
          update_in_browser_mod_list(mod.path, "Failed");
          continue;
        }

        if (
          !mod.env ||
          (mod.env.server !== "required" && mod.env.server !== "optional")
        ) {
          log(`Skipping ${mod.path} (client-only)`, "warn");
          update_in_browser_mod_list(mod.path, "Removed");
          //deleted_mods.push(mod.path + " ( Name not available )");
          continue;
        }

        renderProgress(
          "Downloading server mods",
          i,
          index.files.length,
          modStart,
        );
        update_in_browser_mod_list(mod.path, "Downloading...");

        setPhaseProgress("download", (i + 1) / index.files.length);

        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const blob = await res.blob();
          outputZip.file(mod.path, blob);
          log(`Downloaded ${mod.path}`, "success");
          update_in_browser_mod_list(mod.path, "Downloaded");
        } catch (err: any) {
          log(`Failed to download ${mod.path}: ${err.message}`, "error");
        }
      }
      setPhaseProgress("download", 1);
      renderProgress(
        "Downloading mods",
        index.files.length,
        index.files.length,
        modStart,
      );
      log("All mods downloaded.", "success");

      // --- Overrides phase ---
      const overrides = mrpackZip.folder("overrides");
      if (overrides) {
        const files = Object.values(overrides.files).filter((f) => !f.dir);
        const overrideStart = performance.now();

        log("Applying overrides…", "info");
        setPhaseProgress("overrides", 0);

        let done = 0;
        for (const entry of files) {
          const data = await entry.async("arraybuffer");
          const target = entry.name.replace(/^overrides\//, "");
          outputZip.file(target, data);

          done++;
          renderProgress(
            "Applying overrides",
            done,
            files.length,
            overrideStart,
          );
          setPhaseProgress("overrides", done / files.length);
        }
        setPhaseProgress("overrides", 1);
        log("Overrides applied.", "success");
      } else {
        log("No overrides folder found.", "warn");
        setPhaseProgress("overrides", 1);
      }

      // --- Cleanup phase ---
      log("Cleaning up client-only projects…", "info");
      index.files.forEach((mod: { path: string }) => {
        update_in_browser_mod_list(mod.path, "Analyzing");
      });

      const API_ENDPOINT = "https://api.modrinth.com/v2/projects";
      const BATCH_SIZE = 100;
      const projectIds = index.files
        .map((mod: any) => extractProjectId(mod.downloads?.[0]))
        .filter((id: string | null): id is string => id !== null);
      const uniqueProjectIds = Array.from(new Set(projectIds));
      const projects: Record<string, any> = {};

      // Fetch project metadata
      setPhaseProgress("metadata", 0);
      for (let i = 0; i < uniqueProjectIds.length; i += BATCH_SIZE) {
        const chunk = uniqueProjectIds.slice(i, i + BATCH_SIZE);

        renderProgress(
          "Fetching project metadata",
          Math.min(i + chunk.length, uniqueProjectIds.length),
          uniqueProjectIds.length,
          performance.now(),
        );
        setPhaseProgress(
          "metadata",
          Math.min(i + chunk.length, uniqueProjectIds.length) /
            uniqueProjectIds.length,
        );

        const res = await fetch(
          `${API_ENDPOINT}?ids=${encodeURIComponent(JSON.stringify(chunk))}`,
          {
            headers: { "User-Agent": "NikosStuff/modpack-tool/1.0.0 (web)" },
          },
        );

        if (!res.ok) {
          log(`Failed to fetch project info: HTTP ${res.status}`, "error");
          continue;
        }

        const data = await res.json();
        for (const project of data) projects[project.id] = project;
      }
      setPhaseProgress("metadata", 1);

      // Remove client-only mods
      let removed = 0;
      let processed = 0;
      setPhaseProgress("cleanup", 0);

      for (const mod of index.files) {
        const projectId = extractProjectId(mod.downloads?.[0]);
        if (!projectId) continue;
        const project = projects[projectId];
        if (!project) continue;

        processed++;

        renderProgress(
          "Removing client-only mods",
          processed,
          index.files.length,
          performance.now(),
        );

        if (project.server_side === "unsupported") {
          outputZip.remove(mod.path);
          removed++;
          log(`Removed client-only mod: ${project.title}`, "warn");
          deleted_mods.push(project.title);
          update_in_browser_mod_list(mod.path, "Removed");
        } else {
          update_in_browser_mod_list(mod.path, "Imported");
        }

        setPhaseProgress("cleanup", processed / index.files.length);
      }
      setPhaseProgress("cleanup", 1);

      renderProgress(
        "Cleanup complete",
        index.files.length,
        index.files.length,
        performance.now(),
      );

      if (deleted_mods.length > 0) {
        const deletedContent = `The following client-only mods were removed from the pack:\n\n- ${deleted_mods.join(
          "\n- ",
        )}\n\nYou may need to install these mods manually on your client.`;
        outputZip.file("deleted_mods.txt", deletedContent);
      }

      log(`Cleanup finished. Removed ${removed} client-only mods.`, "info");

      // --- Compress phase ---
      log("Building final ZIP…", "info");
      setPhaseProgress("compress", 0);
      const zipStart = performance.now();

      const finalBlob = await outputZip.generateAsync(
        {
          type: "blob",
          compression: "DEFLATE",
          compressionOptions: { level: 6 },
        },
        (meta) => {
          renderProgress("Compressing", meta.percent ?? 0, 100, zipStart);
          setPhaseProgress("compress", (meta.percent ?? 0) / 100);
        },
      );
      setPhaseProgress("compress", 1);

      const name = `${index.name}-${index.versionId}.zip`.replace(
        /[^\w.-]+/g,
        "_",
      );
      const a = document.createElement("a");
      a.href = URL.createObjectURL(finalBlob);
      a.download = name;
      a.click();
      URL.revokeObjectURL(a.href);

      log("Done! ZIP downloaded.", "success");

      already_running = false;
      reset_phase_progress();
    } catch (err: any) {
      console.error(err);
      log(err.message || "Unknown error", "error");
      alert("Conversion failed — see log");
      already_running = false;
    }
  }

  // thru file input
  fileInput.addEventListener("change", () => {
    const file = fileInput.files?.[0];
    if (file) {
      fileInputText!.textContent = file.name;
      log(`Selected file: ${file.name}`, "info");
      main(file);
    } else {
      fileInputText!.textContent = "No file chosen";
      log("File selection cleared.", "warn");
    }
  });

  // main
  convertBtn.addEventListener("click", async () => {
    const file = fileInput.files?.[0];
    if (!file) {
      alert("Please select a .mrpack file");
      return;
    }

    log(`Loading ${file.name}…`, "info");
    await main(file);
  });

  // thru url input
  url_input!.addEventListener("change", async () => {
    const url = url_input!.value.trim();
    if (!url) {
      alert("Please enter a Modrinth modpack URL");
      return;
    }
    // Example imput: https://modrinth.com/modpack/example
    const modpackIdMatch = url.match(/modrinth\.com\/modpack\/([^\/?#]+)/);
    const modpackId = modpackIdMatch ? modpackIdMatch[1] : null;
    if (!modpackId) {
      alert("Invalid Modrinth modpack URL");
      return;
    }

    const base_url = `https://api.modrinth.com/v2/project/${encodeURIComponent(
      modpackId,
    )}/version`;

    log(`Fetching modpack info for ID: ${modpackId}`, "info");

    // fetch the info with header
    const res = await fetch(base_url, {
      headers: {
        "User-Agent": "NikosStuff/modpack-tool/1.0.0 (web)",
      },
    });

    if (!res.ok) {
      log(`Failed to fetch modpack info: HTTP ${res.status}`, "error");
      return;
    }

    const data = await res.json();
    if (data.length === 0) {
      log("No versions found for the specified modpack ID.", "error");
      return;
    }

    // pick the latest version
    const latest = data[0];
    const fileInfo = latest.files.find((f: any) => f.primary === true);
    if (!fileInfo) {
      log("No primary file found for the latest version.", "error");
      return;
    }

    const downloadUrl = fileInfo.url;
    log(`Fetching modpack from URL: ${downloadUrl}`, "info");
    try {
      const fileRes = await fetch(downloadUrl);
      if (!fileRes.ok) {
        log(`Failed to download modpack: HTTP ${fileRes.status}`, "error");
        return;
      }

      const blob = await fileRes.blob();
      fileInputText!.textContent = fileInfo.filename;
      log(`Downloaded modpack: ${fileInfo.filename}`, "info");
      await main(blob);
    } catch (err: any) {
      log(`Error downloading modpack: ${err.message}`, "error");
    }
  });

  // thru url params
  const modpackId = urlParams.get("modpack_id");
  if (modpackId) {
    const base_url = `https://api.modrinth.com/v2/project/${encodeURIComponent(
      modpackId,
    )}/version`;

    log(`Fetching modpack info for ID: ${modpackId}`, "info");

    // fetch the info with header
    const res = await fetch(base_url, {
      headers: {
        "User-Agent": "NikosStuff/modpack-tool/1.0.0 (web)",
      },
    });

    if (!res.ok) {
      log(`Failed to fetch modpack info: HTTP ${res.status}`, "error");
    } else {
      const data = await res.json();
      if (data.length === 0) {
        log("No versions found for the specified modpack ID.", "error");
      } else {
        // pick the latest version
        const latest = data[0];
        const fileInfo = latest.files.find((f: any) => f.primary === true);
        if (!fileInfo) {
          log("No primary file found for the latest version.", "error");
        } else {
          const downloadUrl = fileInfo.url;
          log(`Fetching modpack from URL: ${downloadUrl}`, "info");
          try {
            const fileRes = await fetch(downloadUrl);
            if (!fileRes.ok) {
              log(
                `Failed to download modpack: HTTP ${fileRes.status}`,
                "error",
              );
            } else {
              const blob = await fileRes.blob();
              fileInputText!.textContent = fileInfo.filename;
              log(`Downloaded modpack: ${fileInfo.filename}`, "info");
              await main(blob);
            }
          } catch (err: any) {
            log(`Error downloading modpack: ${err.message}`, "error");
          }
        }
      }
    }
  }

  // ensure monitoring stops when page unloads
  window.addEventListener("beforeunload", () => {
    stopMonitoring();
  });
</script>
