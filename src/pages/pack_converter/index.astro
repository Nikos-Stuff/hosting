---
import PageLayout from "@layouts/PageLayout.astro";
import { SITE } from "@consts";
import MeteorShower from "@components/MeteorShower.astro";
import TwinklingStars from "@components/TwinklingStars.astro";
import BackgroundFX from "@components/page_effects/BackgroundFX.astro";
import POD from "@components/POD.astro";
import FancyDiv from "@components/FancyDiv.astro";
---

<PageLayout title="Pack Converter" description={SITE.DESCRIPTION}>
  <!-- <script is:inline data-astro-rerun async src="/js/scroll_animation.js"
  ></script> -->

  <POD />
  <!-- Light Mode: Particles -->
  <div class="absolute inset-0 block dark:hidden">
    <div id="particles1" class="fixed inset-0"></div>
    <div id="particles2" class="fixed inset-0"></div>
    <div id="particles3" class="fixed inset-0"></div>
  </div>

  <!-- Dark Theme: Stars -->
  <div class="absolute inset-0 hidden dark:block">
    <div id="stars1" class="fixed inset-0"></div>
    <div id="stars2" class="fixed inset-0"></div>
    <div id="stars3" class="fixed inset-0"></div>
  </div>

  <!-- Dark Theme: Twinkling Stars / Metors -->
  <div id="galaxy" class="fixed inset-0">
    <div class="hidden dark:block">
      <TwinklingStars />
      <MeteorShower />
    </div>
  </div>

  <!-- <script is:inline defer src="/js/bg.js"></script> -->
  <BackgroundFX />

  <!-- HERO -->
  <section
    id="hero_fade"
    class="snap-center grid w-full h-[20svh] place-items-center relative text-center overflow-hidden transition-all"
  >
    <!-- <div id="planetcont" class='animate absolute inset-0 top-3/4 overflow-hidden z-10'> PLANET HAS BEEN REMOVED FOR A TEST NEW LAYOUT 
            <div id="crescent"
                 class='absolute top-0 left-1/2 -translate-x-1/2 w-[250vw] min-h-[100vh] aspect-square rounded-full p-[1px] bg-gradient-to-b from-black/25 dark:from-white/75 from-0% to-transparent to-5%'>
                <div id="planet"
                     class='w-full h-full bg-white dark:bg-black rounded-full p-[1px] overflow-hidden flex justify-center'>
                    <div id="blur" class='w-full h-5 rounded-full bg-neutral-900/25 dark:bg-white/25 blur-2xl'/>
                </div>
            </div>
        </div> -->
  </section>

  <div class="relative">
    <div class="w-svw">
      <FancyDiv isAnimated={true} theme="default_big" margin_bottom="10">
        <div class="transition-all">
          <p
            class="text-xl md:text-2xl lg:text-3xl font-bold uppercase text-black dark:text-white animate"
          >
            Modpack Converter
          </p>
          <p class="font-bold text-sm mb-2 animate">
            Convert .mrpack files to .zip for easy installation (included .jars
            inside)
          </p>

          <div class="space-y-4 animate" id="calculator">
            <!-- URL input -->
            <div class="relative" id="url_input_div">
              <input
                id="url_input"
                type="text"
                placeholder="https://modrinth.com/modpack/example"
                class="w-full p-4 mt-5 border rounded-lg
                    bg-transparent
                  border-black/15 dark:border-white/20
                  hover:bg-black/5 hover:dark:bg-white/10
                    focus:outline-none
                  focus:border-black/40 dark:focus:border-white/40
                    focus:ring-2 focus:ring-black/20 dark:focus:ring-white/20
                    focus:ring-offset-0
                    transition-all duration-300 ease-out"
              />
            </div>

            <p class="text-center italic">or</p>

            <!-- File input-->
            <div class="relative" id="file_input_div">
              <input
                id="file_input"
                type="file"
                accept=".mrpack"
                class="hidden"
              />
              <label
                for="file_input"
                id="file_input_label"
                class="group w-full p-4 mt-5 flex items-center justify-between border rounded-lg
         hover:bg-black/5 hover:dark:bg-white/10 border-black/15 dark:border-white/20
         cursor-pointer transition-all duration-300 ease-in-out"
              >
                <span>Choose File…</span>
                <span
                  id="file_input_text"
                  class="text-gray-500 dark:text-gray-400">No file chosen</span
                >
              </label>
            </div>

            <!-- Convert button -->
            <div class="animate mb-0 hidden">
              <button
                id="convert_to_zip_btn"
                class="group w-full p-4 mt-5 gap-3 flex items-center border rounded-lg hover:bg-black/5 hover:dark:bg-white/10 border-black/15 dark:border-white/20 transition-all duration-300 ease-in-out"
              >
                <span
                  class="w-full z-10 relative group-hover:text-black group-hover:dark:text-white text-center transition-color duration-300"
                >
                  Convert to ZIP server pack!
                </span>
              </button>
            </div>
            <p class="mb-10 mt-0">
              <small
                >Runs in your browser — no uploads. External download links may
                be blocked by CORS.</small
              >
            </p>

            <!-- Modpack browser -->
            <div
              id="modpack_browser"
              class="flex flex-col gap-2 p-4 mt-2 border rounded-lg
              h-60 overflow-y-scroll
            hover:bg-black/5 hover:dark:bg-white/10
            border-black/15 dark:border-white/20
              transition-all duration-300 ease-in-out hide_scrollbar"
            >
              <div
                class="template flex items-center justify-between font-mono text-sm text-gray-700 dark:text-gray-300"
              >
                <div class="flex items-center gap-3 min-w-0">
                  <div
                    class="mod_circle h-2.5 w-2.5 rounded-full shrink-0 aspect-square bg-gray-400 dark:bg-gray-600 animate-pulse"
                  >
                  </div>
                  <span class="mod_name truncate min-w-0"> Mod Name </span>
                </div>
                <span
                  class="mod_status text-right whitespace-nowrap ml-3 shrink-0"
                >
                  Status
                </span>
              </div>
              <!-- content will be dynamically added here -->
            </div>

            <!-- Debug console -->
            <div
              id="debug_console"
              class="font-mono text-sm overflow-scroll h-30 w-full p-4 mt-5 border rounded-lg
              flex flex-col justify-between gap-2
            hover:bg-black/5 hover:dark:bg-white/10
            border-black/15 dark:border-white/20
              transition-all duration-300 ease-in-out hide_scrollbar"
            >
              <div id="log_messages">Waiting for file...</div>
              <div
                id="progress-line"
                class="text-gray-700 dark:text-gray-300 whitespace-pre"
              >
                <!-- progress will update here -->
              </div>
            </div>

            <!-- Resources usage bars -->
            <div class="mt-4 flex gap-4">
              <div class="flex-1">
                <div
                  class="w-full bg-gray-300 dark:bg-gray-700 rounded-full h-[0.3px]"
                >
                  <div
                    id="cpu_usage"
                    class="dark:bg-white bg-black h-[0.3px] rounded-full transition-all duration-500 ease-in-out"
                    style="width: 0%"
                  >
                  </div>
                </div>
              </div>

              <div class="flex-1">
                <div
                  class="w-full bg-gray-300 dark:bg-gray-700 rounded-full h-[0.3px]"
                >
                  <div
                    id="progress_bar"
                    class="dark:bg-white bg-black h-[0.3px] rounded-full transition-all duration-500 ease-in-out"
                    style="width: 0%"
                  >
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </FancyDiv>

      <FancyDiv isAnimated="true" theme="default_big" margin_bottom="50">
        <div class="transition-all">
          <p
            class="text-xl md:text-2xl lg:text-3xl font-bold uppercase text-black dark:text-white animate"
          >
            Modpack Browser
          </p>
          <p class="font-bold text-sm mb-2 animate">
            Quickly search through mods without leaving the page.
          </p>

          <!-- Modpack browser -->
          <div class="mb-3 animate">
            <input
              id="modrint_search"
              type="text"
              placeholder="Search modpacks…"
              class="w-full p-4 mt-5 border rounded-lg
                bg-transparent
                border-black/15 dark:border-white/20
                hover:bg-black/5 hover:dark:bg-white/10
                focus:outline-none
                focus:border-black/40 dark:focus:border-white/40
                focus:ring-2 focus:ring-black/20 dark:focus:ring-white/20
                focus:ring-offset-0
                transition-all duration-300 ease-out"
            />
          </div>

          <div class="animate">
            <div
              id="modrint_mod_browser"
              class="flex flex-col gap-2 p-4 mt-2 border rounded-lg
                   h-125 overflow-y-scroll
                 hover:bg-black/5 hover:dark:bg-white/10
                 border-black/15 dark:border-white/20
                   transition-all duration-300 ease-in-out hide_scrollbar"
            >
              <!-- Template -->
              <div
                class="mdr_template group relative hidden flex-col h-auto border border-black/10 rounded-lg overflow-hidden shrink-0"
              >
                <div
                  class="mdr_template_image absolute inset-0 bg-cover bg-center blur-sm transition-transform duration-500 group-hover:scale-125"
                  style="background-image: url('/imgs/plc.png');"
                >
                </div>
                <div class="absolute inset-0 bg-black/50"></div>

                <div
                  class="relative z-10 p-6 flex flex-col justify-center items-center text-center text-white"
                >
                  <span
                    class="mdr_mod_name block font-bold text-2xl mb-3 transition-all duration-300 group-hover:scale-110"
                  >
                    Mod Name
                  </span>

                  <p
                    class="mdr_modpack_version absolute top-2 left-2 z-20
                     rounded-md bg-black/60 px-2 py-1
                     text-[11px] font-mono text-white
                    transition-all duration-300 group-hover:opacity-0 truncate max-w-1/2"
                  >
                    -
                  </p>

                  <div class="relative w-full">
                    <p
                      class="mdr_mod_description text-base opacity-90 transition-all duration-300 group-hover:opacity-0 group-hover:scale-20"
                    >
                      This is a short description.
                    </p>

                    <p
                      class="click-to-convert absolute inset-0 opacity-0 transition-all duration-300 flex items-center justify-center group-hover:opacity-100 group-hover:scale-110 font-mono"
                    >
                      Click to Convert
                    </p>
                  </div>
                </div>
              </div>

              <!-- Full cover loading -->
              <div
                id="mdr_loading"
                class="hidden absolute inset-0 z-10 items-center justify-center rounded-2xl overflow-hidden"
              >
                <img
                  src="/imgs/plc.png"
                  alt="Loading Meme"
                  class="random_loading_meme absolute inset-0 w-full h-full object-contain animate-pulse"
                />

                <div class="absolute inset-0 bg-black/40"></div>

                <div
                  class="relative z-20 flex flex-col items-center space-y-2 p-2"
                >
                  <p
                    class="mdr_loading_text animate-bounce text-white px-4 py-2 rounded-full bg-black/70 text-lg font-semibold text-center wrap-anywhere break-normal"
                  >
                    Loading modpacks…
                  </p>

                  <p
                    class="text-xs text-white px-3 py-1 rounded-full bg-black/60 animate-pulse text-center"
                  >
                    Stuck? Try another search query!
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </FancyDiv>

      <FancyDiv isAnimated={true} theme="default_big">
        <div class="transition-all">
          <p
            class="text-xl md:text-2xl lg:text-3xl font-bold uppercase text-black dark:text-white animate"
          >
            How to use
          </p>
          <p class="font-bold text-sm mb-2 animate">
            Follow these steps to convert a Modrinth .mrpack file to a
            server-ready .zip file:
          </p>
          <ol class="list-decimal list-inside space-y-2 mt-4 animate">
            <li>
              Obtain a <code>.mrpack</code> file from a Modrinth modpack page.
            </li>
            <li>
              Either upload the <code>.mrpack</code> file using the "Choose File…"
              button, or paste the modpack URL into the input field at the top.
            </li>
            <li>
              Wait for the process to complete. The log and mod browser will
              update with progress information.
            </li>
            <li>
              Once finished, a ZIP file will be automatically downloaded to your
              device.
            </li>
            <li>
              Extract the ZIP file and install the included JAR files on your
              server.
            </li>
            <li>
              If any client-only mods were removed, refer to the
              <code>deleted_mods.txt</code> file inside the ZIP for details.
            </li>
          </ol>

          <div class="mt-6 animate">
            <strong>Note:</strong> This tool runs entirely in your browser. No files
            are uploaded to any server, ensuring your privacy and security. However,
            some external download links may be blocked due to CORS restrictions.
            Also note that large modpacks may take longer to process.<br />
            Pro Tip: You can include advanced search queries in the modpack browser,
            such as <code>[version:1.20.4]</code> or <code>[loader:fabric]</code
            > to filter modpacks by Minecraft version or mod loader.
          </div>
        </div>
      </FancyDiv>
    </div>
  </div>
</PageLayout>

<script>
  const browser = document.getElementById(
    "modrint_mod_browser",
  ) as HTMLDivElement | null;
  const searchInput = document.getElementById(
    "modrint_search",
  ) as HTMLInputElement | null;
  const converter_url_input = document.getElementById(
    "url_input",
  ) as HTMLInputElement | null;
  const loading_screen = document.getElementById(
    "mdr_loading",
  ) as HTMLDivElement | null;

  const random_loading_text = [
    "Navigating the Labyrinth...",
    "Querying the Modrinth index...",
    "Fetching projects from the Labyrinth...",
    "Walking the green path to your modpacks...",
    "Locating curated modpack gems...",
    "Pulling metadata from the Modrinth core...",
    "Exploring the depths of the Labyrinth...",
    "Polishing the Modrinth search results...",
    "Venturing into the Modrinth multiverse...",
    "Synchronizing with the Labyrinth nodes...",
    "Optimizing your modpack discovery...",
    "Connecting to the open-source source...",
    "Harvesting the latest modpack releases...",
    "Lost in the Labyrinth? Just kidding, fetching now...",
    "Filtering through the Modrinth archives...",
    "Summoning modpacks from the Labyrinth depths...",
    "Getting stuck in the Modrinth maze...",
    "*jazz music stops*",
    "AAAAAAAAAAAAAAAAAAAAAAA...",
  ];

  if (!browser || !searchInput || !converter_url_input || !loading_screen) {
    throw new Error("Required DOM elements not found");
  }

  const API_BASE = "https://api.modrinth.com/v2";
  const template = browser.querySelector(".mdr_template") as HTMLDivElement;

  const facetAliases: Record<string, string> = {
    version: "versions",
    loader: "categories",
  };

  // clear browser content
  function clearBrowser() {
    browser!
      .querySelectorAll(".mdr_template:not(.hidden)")
      .forEach((el) => el.remove());

    loading_screen?.classList.add("flex");
    loading_screen?.classList.remove("hidden");
  }

  // randomize loading screen meme and text
  function radomize_loading_screen() {
    const meme_url_endpoint = "https://meme-api.com/gimme/ProgrammerHumor";
    const randomIndex = Math.floor(Math.random() * random_loading_text.length);
    const randomText = random_loading_text[randomIndex];
    const loadingTextElem = loading_screen?.querySelector(
      ".mdr_loading_text",
    ) as HTMLParagraphElement;
    const randomMemeElem = loading_screen?.querySelector(
      ".random_loading_meme",
    ) as HTMLImageElement;

    fetch(meme_url_endpoint)
      .then((response) => response.json())
      .then((data) => {
        // if (randomMemeElem && data.preview && data.preview.length > 0) {
        //   // pick the largest preview available
        //   const largestPreview = data.preview[data.preview.length - 1];
        //   randomMemeElem.src = largestPreview;
        // get the url image
        if (randomMemeElem && data.url) {
          randomMemeElem.src = data.url;
          // 50/50 chance of getting the normal loading text or the meme title
          if (Math.random() < 0.5) {
            loadingTextElem.textContent = randomText;
          } else {
            loadingTextElem.textContent = data.title;
          }
        }
      })
      .catch((error) => {
        console.warn("Failed to fetch random meme:", error);
      });
  }

  // fetch project versions
  async function fetchProjectVersions(
    slug: string,
    gameVersion?: string,
    loader?: string,
  ) {
    const params = new URLSearchParams();
    if (gameVersion) params.append("game_versions", gameVersion);
    if (loader) params.append("loaders", loader);

    const res = await fetch(
      `${API_BASE}/project/${slug}/version?${params.toString()}`,
    );
    return res.json(); // returns array of version objects
  }

  // create a mod card
  function createCard(mod: any): HTMLDivElement {
    const card = template.cloneNode(true) as HTMLDivElement;
    card.classList.remove("hidden");
    card.classList.add("flex");

    const image = card.querySelector(".mdr_template_image") as HTMLDivElement;
    const name = card.querySelector(".mdr_mod_name") as HTMLSpanElement;
    const desc = card.querySelector(
      ".mdr_mod_description",
    ) as HTMLParagraphElement;
    const versionBadge = card.querySelector(
      ".mdr_modpack_version",
    ) as HTMLParagraphElement;

    // Pick the first filtered version
    const matchedVersion = mod.filteredVersions?.[0];

    if (matchedVersion) {
      const loaders = matchedVersion.loaders?.join(", ") || "Unknown loader";
      const gameVersions =
        matchedVersion.game_versions?.join(", ") || "Unknown version";
      versionBadge.textContent = `${gameVersions} - ${loaders}`;
    } else {
      versionBadge.textContent = "No matching version";
    }

    const bg = mod.icon_url || mod.gallery?.[0] || "/imgs/plc.png";
    image.style.backgroundImage = `url("${bg}")`;
    name.textContent = mod.title;
    desc.textContent = mod.description ?? "No description";

    card.addEventListener("click", () => {
      const targetUrl = matchedVersion
        ? `https://modrinth.com/project/${mod.slug}/version/${matchedVersion.id}`
        : `https://modrinth.com/modpack/${mod.slug}`;

      converter_url_input!.value = targetUrl;
      converter_url_input!.dispatchEvent(
        new Event("change", { bubbles: true }),
      );
      window.scrollTo({ top: 0, behavior: "smooth" });
    });

    if (!browser) return card;
    browser.appendChild(card);
    return card;
  }

  // render hits
  async function render(
    hits: any[] | undefined,
    gameVersion?: string,
    loader?: string,
  ) {
    //clearBrowser();

    console.log("Rendering hits:", hits);

    if (!browser || !hits || hits.length === 0) return;

    const hitsWithVersions = await Promise.all(
      hits.map(async (mod) => {
        let versions = await fetchProjectVersions(
          mod.slug,
          gameVersion,
          loader,
        );

        if (!versions) return null; // safety check

        if (gameVersion) {
          versions = versions.filter(
            (v: { game_versions: string | string[] }) =>
              v.game_versions.includes(gameVersion),
          );
        }
        if (loader) {
          versions = versions.filter((v: { loaders: string | string[] }) =>
            v.loaders?.includes(loader),
          );
        }

        if (!versions || versions.length === 0) return null;

        versions.sort(
          (
            a: { date_published: string | number | Date },
            b: { date_published: string | number | Date },
          ) =>
            new Date(b.date_published).getTime() -
            new Date(a.date_published).getTime(),
        );
        return { ...mod, filteredVersions: versions };
      }),
    );

    hitsWithVersions
      .filter(Boolean) // remove nulls
      .forEach((mod) => createCard(mod));

    loading_screen?.classList.add("hidden");
    loading_screen?.classList.remove("flex");
    radomize_loading_screen();
  }

  // random modpacks
  async function loadRandom() {
    clearBrowser();

    try {
      const res = await fetch(`${API_BASE}/projects_random?count=70`);
      const data = await res.json();

      const filtered = data
        .filter(
          (p: any) =>
            p.project_type === "modpack" && p.server_side === "required",
        )
        .slice(0, 10);

      render(filtered);
    } catch (err) {
      console.error("Failed to load random modpacks", err);
    }
  }

  // search
  async function search(query: string) {
    if (!query.trim()) {
      loadRandom();
      return;
    }

    clearBrowser();

    // manage [version:...] and [loader:...] filters
    const advancedMatches = Array.from(query.matchAll(/\[(.+?):(.+?)\]/g));
    let gameVersion: string | undefined;
    let loader: string | undefined;

    advancedMatches.forEach((match) => {
      const key = facetAliases[match[1].trim()] ?? match[1].trim();
      const value = match[2].trim();

      if (key === "versions") gameVersion = value;
      if (key === "categories") loader = value;
    });

    // remove tags from query
    query = query.replace(/\[(.+?):(.+?)\]/g, "").trim();

    const facets = [["project_type:modpack"], ["server_side:required"]];
    if (gameVersion) facets.push([`versions:${gameVersion}`]);
    if (loader) facets.push([`categories:${loader}`]);

    const url = `${API_BASE}/search?query=${encodeURIComponent(query)}&limit=10&facets=${encodeURIComponent(JSON.stringify(facets))}`;

    try {
      const res = await fetch(url);
      const data = await res.json();
      render(data.hits, gameVersion, loader);
    } catch (err) {
      console.error("Search failed", err);
    }
  }

  // main
  let timeout: number;
  searchInput.addEventListener("change", () => {
    clearTimeout(timeout);
    timeout = window.setTimeout(() => {
      search(searchInput.value);
    }, 300);
  });

  loadRandom();
</script>

<script>
  import JSZip from "jszip";

  const fileInput = document.getElementById(
    "file_input",
  ) as HTMLInputElement | null;
  const convertBtn = document.getElementById(
    "convert_to_zip_btn",
  ) as HTMLButtonElement | null;
  const debugConsole = document.getElementById(
    "debug_console",
  ) as HTMLDivElement | null;
  const fileInputText = document.getElementById(
    "file_input_text",
  ) as HTMLSpanElement | null;
  const modpack_browser = document.getElementById(
    "modpack_browser",
  ) as HTMLDivElement | null;
  const url_input = document.getElementById(
    "url_input",
  ) as HTMLInputElement | null;
  const cpu_usage_bar = document.getElementById(
    "cpu_usage",
  ) as HTMLDivElement | null;
  const progress_bar = document.getElementById(
    "progress_bar",
  ) as HTMLDivElement | null;

  const deleted_mods: string[] = [];
  let already_running = false;

  if (!fileInput || !convertBtn || !debugConsole) {
    throw new Error("Required DOM elements not found");
  }

  // grab url params eg ?modpack_id=xyz
  const urlParams = new URLSearchParams(window.location.search);

  type LogLevel = "info" | "warn" | "error" | "success";

  const LOG_COLORS: Record<LogLevel, string> = {
    info: "text-blue-600 dark:text-blue-400",
    warn: "text-yellow-600 dark:text-yellow-400",
    error: "text-red-600 dark:text-red-400",
    success: "text-green-600 dark:text-green-400",
  };

  const STATUS_COLORS: Record<string, string[]> = {
    Queued: ["bg-gray-400", "dark:bg-gray-600"],
    "Downloading...": ["bg-blue-500"],
    Downloaded: ["bg-blue-300"],
    Imported: ["bg-green-500"],
    Failed: ["bg-red-500"],
    Skipped: ["bg-yellow-500"],
    "Cleaned Up": ["bg-yellow-600"],
    Analyzing: ["bg-purple-500"],
  };

  type Phase =
    | "load"
    | "download"
    | "overrides"
    | "metadata"
    | "cleanup"
    | "compress";

  const PHASE_WEIGHTS: Record<Phase, number> = {
    load: 5,
    download: 45,
    overrides: 10,
    metadata: 15,
    cleanup: 10,
    compress: 15,
  };

  const phaseProgress: Record<Phase, number> = {
    load: 0,
    download: 0,
    overrides: 0,
    metadata: 0,
    cleanup: 0,
    compress: 0,
  };

  let monitorInterval: number | null = null;
  const lagSamples: number[] = [];
  const LAG_WINDOW_MS = 5000;
  const INTERVAL_MS = 500;

  // ---------------------------------------------------------------

  function updateCircleColor(circle: HTMLDivElement, status: string) {
    const classesToRemove = Array.from(circle.classList).filter(
      (c) => c.startsWith("bg-") || c.startsWith("dark:bg-"),
    );
    circle.classList.remove(...classesToRemove);

    const newClasses = STATUS_COLORS[status] || [
      "bg-gray-400",
      "dark:bg-gray-600",
    ];
    circle.classList.add(...newClasses);
  }

  function add_to_browser_mod_list(mod_name: string, status: string) {
    if (!modpack_browser) return;

    const template = modpack_browser.querySelector(
      ".template",
    ) as HTMLDivElement;
    if (!template) return;

    const modEntry = template.cloneNode(true) as HTMLDivElement;
    modEntry.classList.remove("template");

    const modNameSpan = modEntry.querySelector(".mod_name") as HTMLSpanElement;
    const modStatusSpan = modEntry.querySelector(
      ".mod_status",
    ) as HTMLSpanElement;
    const statusCircle = modEntry.querySelector(
      ".mod_circle",
    ) as HTMLDivElement;

    if (modNameSpan) modNameSpan.textContent = mod_name;
    if (modStatusSpan) modStatusSpan.textContent = status;
    if (statusCircle) updateCircleColor(statusCircle, status);

    modpack_browser.appendChild(modEntry);
  }

  function update_in_browser_mod_list(mod_name: string, status: string) {
    if (!modpack_browser) return;

    const entries = modpack_browser.querySelectorAll(
      "div:not(.template)",
    ) as NodeListOf<HTMLDivElement>;

    entries.forEach((entry) => {
      const modNameSpan = entry.querySelector(".mod_name") as HTMLSpanElement;
      const modStatusSpan = entry.querySelector(
        ".mod_status",
      ) as HTMLSpanElement;
      const statusCircle = entry.querySelector(".mod_circle") as HTMLDivElement;

      if (modNameSpan && modNameSpan.textContent === mod_name) {
        if (modStatusSpan) modStatusSpan.textContent = status;
        if (statusCircle) updateCircleColor(statusCircle, status);
      }
    });

    // scroll to the updated mod only inside the modpack browser
    const targetEntry = Array.from(entries).find((entry) => {
      const modNameSpan = entry.querySelector(".mod_name") as HTMLSpanElement;
      return modNameSpan && modNameSpan.textContent === mod_name;
    });
    if (targetEntry && modpack_browser) {
      const container = modpack_browser as HTMLElement;
      const entry = targetEntry as HTMLElement;

      // compute entry position relative to the container and center it
      const containerRect = container.getBoundingClientRect();
      const entryRect = entry.getBoundingClientRect();
      const offset =
        entryRect.top -
        containerRect.top +
        container.scrollTop -
        container.clientHeight / 2 +
        entry.clientHeight / 2;

      container.scrollTo({ top: offset, behavior: "smooth" });
    }
  }

  function clean_browser_mod_list() {
    if (!modpack_browser) return;

    Array.from(modpack_browser.children).forEach((child) => {
      const el = child as HTMLDivElement;
      if (!el.classList.contains("template")) {
        el.remove();
      }
    });
  }

  function reset_phase_progress() {
    for (const phase in phaseProgress) {
      phaseProgress[phase as Phase] = 0;
    }
    updateOverallProgressBar();
  }

  function clear_log() {
    const container = document.getElementById("log_messages");
    if (container) {
      container.innerHTML = "";
    }
  }

  function log(message: string, level: LogLevel = "info") {
    const time = new Date().toLocaleTimeString();
    const line = `
    <div class="${LOG_COLORS[level]}">
      [${time}] ${message}
    </div>
  `;
    const container = document.getElementById("log_messages");
    if (container) {
      container.innerHTML += line;
      debugConsole!.scrollTop = debugConsole!.scrollHeight;
    }
  }

  //  const PROGRESS_ID = "progress-line";

  function formatETA(seconds: number): string {
    if (seconds === 0) return "Completed!";
    if (!isFinite(seconds) || seconds < 0) return "calculating…";
    if (seconds < 60) return `${Math.ceil(seconds)}s`;

    const m = Math.floor(seconds / 60);
    const s = Math.ceil(seconds % 60);
    return `${m}m ${s}s`;
  }

  function renderProgress(
    label: string,
    current: number,
    total: number,
    startTime: number,
  ) {
    const percent =
      total > 0 ? Math.min(100, Math.floor((current / total) * 100)) : 0;
    const barLength = 20;
    const filled = Math.floor((percent / 100) * barLength);
    const remainingBar = barLength - filled;

    const bar =
      "=".repeat(filled) +
      (remainingBar > 0 ? ">" : "") +
      " ".repeat(Math.max(0, remainingBar - 1));

    const elapsed = (performance.now() - startTime) / 1000;
    const rate = current / elapsed;
    const remainingTime = rate > 0 ? (total - current) / rate : Infinity;

    const progressDiv = document.getElementById("progress-line");
    if (progressDiv) {
      progressDiv.innerHTML = `${label} [${bar}] ${percent}% (${Math.round(current)}/${total}) • ETA ${formatETA(remainingTime)}`;
    }

    debugConsole!.scrollTop = debugConsole!.scrollHeight;
  }

  function extractProjectId(url: string): string | null {
    const match = url.match(/cdn\.modrinth\.com\/data\/([^/]+)\//);
    return match?.[1] ?? null;
  }

  function updateCPUbar(cpuPercent: number | null) {
    if (cpu_usage_bar) {
      cpu_usage_bar.style.width = `${cpuPercent ?? 0}%`;
      cpu_usage_bar.title =
        cpuPercent !== null
          ? `CPU approx: ${Math.round(cpuPercent)}%`
          : "CPU approx: N/A";
    }
  }

  function getOverallProgressPercent(): number {
    let total = 0;

    for (const phase in PHASE_WEIGHTS) {
      const p = phase as Phase;
      total += phaseProgress[p] * PHASE_WEIGHTS[p];
    }

    return Math.min(100, Math.max(0, total));
  }

  function updateOverallProgressBar() {
    const pct = getOverallProgressPercent();

    if (!progress_bar) return;

    progress_bar.style.width = `${pct}%`;
    progress_bar.title = `Overall progress: ${Math.round(pct)}%`;
  }

  function setPhaseProgress(phase: Phase, value: number) {
    phaseProgress[phase] = Math.max(phaseProgress[phase], Math.min(1, value));
    updateOverallProgressBar();
  }

  // lag based CPU approximation
  let lastTick = performance.now();
  function monitorLoop() {
    const now = performance.now();
    const delta = now - lastTick;
    lastTick = now;
    // expected interval ~ INTERVAL_MS; lag = how much slower than expected
    const lag = Math.max(0, delta - INTERVAL_MS);
    lagSamples.push(lag);
    // keep window
    //const cutoff = now - LAG_WINDOW_MS;
    while (
      lagSamples.length > 0 &&
      lagSamples.length * INTERVAL_MS > LAG_WINDOW_MS
    ) {
      lagSamples.shift();
    }

    // average lag over samples
    const avgLag =
      lagSamples.reduce((a, b) => a + b, 0) / Math.max(1, lagSamples.length);

    // map avgLag to a rough CPU percent: 0 lag -> ~5% , 200ms lag -> ~100%
    const cpuPercent = Math.min(100, Math.max(0, (avgLag / 200) * 100));

    // const memPercent = getMemoryUsagePercent();

    updateCPUbar(
      Math.round(cpuPercent),
      // memPercent !== null ? Math.round(memPercent) : null,
    );
  }

  function startMonitoring() {
    if (monitorInterval !== null) return;
    lastTick = performance.now();
    monitorInterval = window.setInterval(monitorLoop, INTERVAL_MS);
  }

  function stopMonitoring() {
    if (monitorInterval !== null) {
      clearInterval(monitorInterval);
      monitorInterval = null;
    }
  }

  // start monitoring immediately
  startMonitoring();

  // ---------------------------------------------------------------

  async function main(file: File | Blob) {
    try {
      if (already_running) {
        log("Conversion already in progress. Please wait.", "warn");
        return;
      }

      clean_browser_mod_list();
      clear_log();
      reset_phase_progress();

      already_running = true;

      // load phase
      setPhaseProgress("load", 0);
      const mrpackZip = await JSZip.loadAsync(file);
      log("MRPACK loaded.", "success");
      setPhaseProgress("load", 1);

      const indexFile = mrpackZip.file("modrinth.index.json");
      if (!indexFile) throw new Error("modrinth.index.json not found");

      const index = JSON.parse(await indexFile.async("string"));

      log(`Modpack: ${index.name} (${index.versionId})`, "info");
      log(`Mods to download: ${index.files.length}`, "info");

      const outputZip = new JSZip();

      // Populate browser mod list
      log(`Populating mod browser...`, "info");
      index.files.forEach((mod: { path: string }) => {
        add_to_browser_mod_list(mod.path, "Queued");
      });

      // download stuff
      setPhaseProgress("download", 0);
      const modStart = performance.now();
      for (let i = 0; i < index.files.length; i++) {
        const mod = index.files[i];
        const url = mod.downloads?.[0];

        if (!url) {
          log(`Skipping ${mod.path} (no URL)`, "warn");
          update_in_browser_mod_list(mod.path, "Failed");
          continue;
        }

        if (
          !mod.env ||
          (mod.env.server !== "required" && mod.env.server !== "optional")
        ) {
          log(`Skipping ${mod.path} (client-only)`, "warn");
          update_in_browser_mod_list(mod.path, "Skipped");
          //deleted_mods.push(mod.path + " ( Name not available )");
          continue;
        }

        renderProgress(
          "Downloading server mods",
          i,
          index.files.length,
          modStart,
        );
        update_in_browser_mod_list(mod.path, "Downloading...");

        setPhaseProgress("download", (i + 1) / index.files.length);

        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const blob = await res.blob();
          outputZip.file(mod.path, blob);
          log(`Downloaded ${mod.path}`, "success");
          update_in_browser_mod_list(mod.path, "Downloaded");
        } catch (err: any) {
          log(`Failed to download ${mod.path}: ${err.message}`, "error");
        }
      }
      setPhaseProgress("download", 1);
      renderProgress(
        "Downloading mods",
        index.files.length,
        index.files.length,
        modStart,
      );
      log("All mods downloaded.", "success");

      // configure overrides
      const overrides = mrpackZip.folder("overrides");
      if (overrides) {
        const files = Object.values(overrides.files).filter((f) => !f.dir);
        const overrideStart = performance.now();

        log("Applying overrides…", "info");
        setPhaseProgress("overrides", 0);

        let done = 0;
        for (const entry of files) {
          const data = await entry.async("arraybuffer");
          const target = entry.name.replace(/^overrides\//, "");
          outputZip.file(target, data);

          done++;
          renderProgress(
            "Applying overrides",
            done,
            files.length,
            overrideStart,
          );
          setPhaseProgress("overrides", done / files.length);
        }
        setPhaseProgress("overrides", 1);
        log("Overrides applied.", "success");
      } else {
        log("No overrides folder found.", "warn");
        setPhaseProgress("overrides", 1);
      }

      // remove useless mods
      log("Cleaning up client-only projects…", "info");
      index.files.forEach((mod: { path: string }) => {
        update_in_browser_mod_list(mod.path, "Analyzing");
      });

      const API_ENDPOINT = "https://api.modrinth.com/v2/projects";
      const BATCH_SIZE = 100;
      const projectIds = index.files
        .map((mod: any) => extractProjectId(mod.downloads?.[0]))
        .filter((id: string | null): id is string => id !== null);
      const uniqueProjectIds = Array.from(new Set(projectIds));
      const projects: Record<string, any> = {};

      // Fetch project metadata
      setPhaseProgress("metadata", 0);
      for (let i = 0; i < uniqueProjectIds.length; i += BATCH_SIZE) {
        const chunk = uniqueProjectIds.slice(i, i + BATCH_SIZE);

        renderProgress(
          "Fetching project metadata",
          Math.min(i + chunk.length, uniqueProjectIds.length),
          uniqueProjectIds.length,
          performance.now(),
        );
        setPhaseProgress(
          "metadata",
          Math.min(i + chunk.length, uniqueProjectIds.length) /
            uniqueProjectIds.length,
        );

        const res = await fetch(
          `${API_ENDPOINT}?ids=${encodeURIComponent(JSON.stringify(chunk))}`,
          {
            headers: { "User-Agent": "NikosStuff/modpack-tool/1.0.0 (web)" },
          },
        );

        if (!res.ok) {
          log(`Failed to fetch project info: HTTP ${res.status}`, "error");
          continue;
        }

        const data = await res.json();
        for (const project of data) projects[project.id] = project;
      }
      setPhaseProgress("metadata", 1);

      // Remove client-only mods
      let removed = 0;
      let processed = 0;
      setPhaseProgress("cleanup", 0);

      for (const mod of index.files) {
        const projectId = extractProjectId(mod.downloads?.[0]);
        if (!projectId) continue;
        const project = projects[projectId];
        if (!project) continue;

        processed++;

        renderProgress(
          "Removing client-only mods",
          processed,
          index.files.length,
          performance.now(),
        );

        if (project.server_side === "unsupported") {
          outputZip.remove(mod.path);
          removed++;
          log(`Cleaned up client-only mod: ${project.title}`, "warn");
          deleted_mods.push(project.title);
          update_in_browser_mod_list(mod.path, "Cleaned Up");
          // small delay to not kill user browser lmao
          await new Promise((r) => setTimeout(r, 50));
        } else {
          update_in_browser_mod_list(mod.path, "Imported");
        }

        setPhaseProgress("cleanup", processed / index.files.length);
      }
      setPhaseProgress("cleanup", 1);

      renderProgress(
        "Cleanup complete",
        index.files.length,
        index.files.length,
        performance.now(),
      );

      if (deleted_mods.length > 0) {
        const deletedContent = `The following client-only mods were removed from the pack:\n\n- ${deleted_mods.join(
          "\n- ",
        )}\n\nYou may need to install these mods manually on your client.`;
        outputZip.file("deleted_mods.txt", deletedContent);
      }

      log(`Cleanup finished. Removed ${removed} client-only mods.`, "info");

      // compress into zip and serve back
      log("Building final ZIP…", "info");
      setPhaseProgress("compress", 0);
      const zipStart = performance.now();

      const finalBlob = await outputZip.generateAsync(
        {
          type: "blob",
          compression: "DEFLATE",
          compressionOptions: { level: 6 },
        },
        (meta) => {
          renderProgress("Compressing", meta.percent ?? 0, 100, zipStart);
          setPhaseProgress("compress", (meta.percent ?? 0) / 100);
        },
      );
      setPhaseProgress("compress", 1);

      const name = `${index.name}-${index.versionId}.zip`.replace(
        /[^\w.-]+/g,
        "_",
      );
      const a = document.createElement("a");
      a.href = URL.createObjectURL(finalBlob);
      a.download = name;
      a.click();
      URL.revokeObjectURL(a.href);

      log("Done! ZIP downloaded.", "success");

      already_running = false;
      reset_phase_progress();
    } catch (err: any) {
      console.error(err);
      log(err.message || "Unknown error", "error");
      alert("Conversion failed — see log");
      already_running = false;
    }
  }

  // thru file input
  fileInput.addEventListener("change", () => {
    const file = fileInput.files?.[0];
    if (file) {
      fileInputText!.textContent = file.name;
      log(`Selected file: ${file.name}`, "info");
      main(file);
    } else {
      fileInputText!.textContent = "No file chosen";
      log("File selection cleared.", "warn");
    }
  });

  // main
  convertBtn.addEventListener("click", async () => {
    const file = fileInput.files?.[0];
    if (!file) {
      alert("Please select a .mrpack file");
      return;
    }

    log(`Loading ${file.name}…`, "info");
    await main(file);
  });

  // thru url input
  url_input!.addEventListener("change", async () => {
    const url = url_input!.value.trim();
    if (!url) {
      alert("Please enter a Modrinth modpack URL");
      return;
    }

    // Check if it’s a specific version URL
    const versionMatch = url.match(
      /modrinth\.com\/project\/([^\/?#]+)\/version\/([^\/?#]+)/,
    );
    const modpackMatch = url.match(/modrinth\.com\/modpack\/([^\/?#]+)/);

    let modpackId: string | null = null;
    let versionId: string | null = null;

    if (versionMatch) {
      modpackId = versionMatch[1];
      versionId = versionMatch[2];
    } else if (modpackMatch) {
      modpackId = modpackMatch[1];
    } else {
      alert("Invalid Modrinth modpack URL");
      return;
    }

    log(`Fetching modpack info for ID: ${modpackId}`, "info");

    let versionsUrl = `https://api.modrinth.com/v2/project/${encodeURIComponent(modpackId)}/version`;
    if (versionId) {
      // If a specific version is requested, fetch that version only
      versionsUrl += `/${encodeURIComponent(versionId)}`;
    }

    try {
      const res = await fetch(versionsUrl, {
        headers: {
          "User-Agent": "NikosStuff/modpack-tool/1.0.0 (web)",
        },
      });

      if (!res.ok) {
        log(`Failed to fetch modpack info: HTTP ${res.status}`, "error");
        return;
      }

      let data: any;
      if (versionId) {
        // API returns a single object for a specific version
        data = [await res.json()];
      } else {
        data = await res.json(); // array of all versions
      }

      if (data.length === 0) {
        log("No versions found for the specified modpack ID.", "error");
        return;
      }

      // pick latest if version not specified
      const selected = versionId ? data[0] : data[0];
      const fileInfo = selected.files.find((f: any) => f.primary === true);
      if (!fileInfo) {
        log("No primary file found for the selected version.", "error");
        return;
      }

      const downloadUrl = fileInfo.url;
      log(`Fetching modpack from URL: ${downloadUrl}`, "info");

      const fileRes = await fetch(downloadUrl);
      if (!fileRes.ok) {
        log(`Failed to download modpack: HTTP ${fileRes.status}`, "error");
        return;
      }

      const blob = await fileRes.blob();
      fileInputText!.textContent = fileInfo.filename;
      log(`Downloaded modpack: ${fileInfo.filename}`, "info");
      await main(blob);
    } catch (err: any) {
      log(`Error downloading modpack: ${err.message}`, "error");
    }
  });

  // thru url params
  const modpackId = urlParams.get("modpack_id");
  if (modpackId) {
    const base_url = `https://api.modrinth.com/v2/project/${encodeURIComponent(
      modpackId,
    )}/version`;

    log(`Fetching modpack info for ID: ${modpackId}`, "info");

    // fetch the info with header
    const res = await fetch(base_url, {
      headers: {
        "User-Agent": "NikosStuff/modpack-tool/1.0.0 (web)",
      },
    });

    if (!res.ok) {
      log(`Failed to fetch modpack info: HTTP ${res.status}`, "error");
    } else {
      const data = await res.json();
      if (data.length === 0) {
        log("No versions found for the specified modpack ID.", "error");
      } else {
        // pick the latest version
        const latest = data[0];
        const fileInfo = latest.files.find((f: any) => f.primary === true);
        if (!fileInfo) {
          log("No primary file found for the latest version.", "error");
        } else {
          const downloadUrl = fileInfo.url;
          log(`Fetching modpack from URL: ${downloadUrl}`, "info");
          try {
            const fileRes = await fetch(downloadUrl);
            if (!fileRes.ok) {
              log(
                `Failed to download modpack: HTTP ${fileRes.status}`,
                "error",
              );
            } else {
              const blob = await fileRes.blob();
              fileInputText!.textContent = fileInfo.filename;
              log(`Downloaded modpack: ${fileInfo.filename}`, "info");
              await main(blob);
            }
          } catch (err: any) {
            log(`Error downloading modpack: ${err.message}`, "error");
          }
        }
      }
    }
  }

  // ensure monitoring stops when page unloads
  window.addEventListener("beforeunload", () => {
    stopMonitoring();
  });
</script>
